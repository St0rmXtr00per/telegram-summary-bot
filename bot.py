import logging
import os
import sys
import asyncio
import aiohttp
from flask import Flask, request, jsonify
from telegram import Update
from telegram.constants import ChatAction, ParseMode
from telegram.ext import ApplicationBuilder, ContextTypes, MessageHandler, CommandHandler, filters
from docx import Document
import threading

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Flask app –¥–ª—è –≤–µ–±—Ö—É–∫–∞
app = Flask(__name__)

# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫
BOT_TOKEN = os.getenv("BOT_TOKEN")
HUGGINGFACE_API_KEY = os.getenv("HUGGINGFACE_API_KEY")
HUGGINGFACE_MODEL = os.getenv("HUGGINGFACE_MODEL", "IlyaGusev/mbart_ru_sum_gazeta")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")

if not BOT_TOKEN:
    logger.error("BOT_TOKEN environment variable is not set!")
    sys.exit(1)
if not HUGGINGFACE_API_KEY:
    logger.error("HUGGINGFACE_API_KEY environment variable is not set!")
    sys.exit(1)
if not WEBHOOK_URL:
    logger.error("WEBHOOK_URL environment variable is not set!")
    sys.exit(1)

# –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è application
application = None

# –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ –∏ API (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
def prepare_episode_text(text: str) -> str:
    lines = text.split('\n')
    cleaned_lines = []
    
    for line in lines:
        line = line.strip()
        if line and '[' in line and ']' in line:
            if '-->' not in line and not line.isdigit():
                cleaned_lines.append(line)
    
    episode_text = ' '.join(cleaned_lines)
    
    max_chars = 3000
    if len(episode_text) > max_chars:
        quarter = max_chars // 4
        episode_text = episode_text[:quarter*3] + "..." + episode_text[-quarter:]
    
    return episode_text

async def summarize_episode_with_huggingface(episode_text: str, file_name: str) -> str:
    try:
        prompt = f"""–°–æ–∑–¥–∞–π –∫—Ä–∞—Ç–∫–∏–π –ø–µ—Ä–µ—Å–∫–∞–∑ —ç—Ç–æ–π —Å–µ—Ä–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∏–∞–ª–æ–≥–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π.
        
–í–ê–ñ–ù–´–ï –¢–†–ï–ë–û–í–ê–ù–ò–Ø:
- –ò—Å–ø–æ–ª—å–∑—É–π –¢–û–õ–¨–ö–û –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
- –ù–ï –¥–æ–±–∞–≤–ª—è–π –Ω–∏—á–µ–≥–æ –æ—Ç —Å–µ–±—è
- –°–æ—Å—Ä–µ–¥–æ—Ç–æ—á—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—ã—Ö —Å–æ–±—ã—Ç–∏—è—Ö —Å–µ—Ä–∏–∏
- –£–ø–æ–º–∏–Ω–∞–π –∏–º–µ–Ω–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π –∏–∑ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–æ–∫
- –ü–µ—Ä–µ—Å–∫–∞–∑ –¥–æ–ª–∂–µ–Ω —á–∏—Ç–∞—Ç—å—Å—è –∑–∞ 2 –º–∏–Ω—É—Ç—ã
- –ù–µ –æ–ø–∏—Å—ã–≤–∞–π –º–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏

–¢–µ–∫—Å—Ç —Å–µ—Ä–∏–∏:
{episode_text}

–ö—Ä–∞—Ç–∫–∏–π –ø–µ—Ä–µ—Å–∫–∞–∑ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π —Å–µ—Ä–∏–∏:"""

        api_url = f"https://api-inference.huggingface.co/models/{HUGGINGFACE_MODEL}"
        
        headers = {
            "Authorization": f"Bearer {HUGGINGFACE_API_KEY}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "inputs": prompt,
            "parameters": {
                "max_length": 300,
                "min_length": 100,
                "do_sample": False,
                "temperature": 0.3,
                "repetition_penalty": 1.1
            }
        }
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
            async with session.post(api_url, headers=headers, json=payload) as response:
                if response.status == 200:
                    result = await response.json()
                    if isinstance(result, list) and len(result) > 0:
                        summary = result[0].get('summary_text', '')
                        if not summary:
                            summary = result[0].get('generated_text', '')
                            if prompt in summary:
                                summary = summary.replace(prompt, '').strip()
                        
                        if summary:
                            return format_episode_summary(summary, file_name)
                        else:
                            return "‚ùå –ú–æ–¥–µ–ª—å –Ω–µ —Å–º–æ–≥–ª–∞ —Å–æ–∑–¥–∞—Ç—å –ø–µ—Ä–µ—Å–∫–∞–∑"
                    else:
                        return "‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç API"
                elif response.status == 503:
                    return "‚è≥ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ 1-2 –º–∏–Ω—É—Ç—ã"
                elif response.status == 429:
                    return "‚è≥ –ü—Ä–µ–≤—ã—à–µ–Ω—ã –ª–∏–º–∏—Ç—ã API, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ"
                else:
                    error_text = await response.text()
                    logger.error(f"Hugging Face API error: {response.status} - {error_text}")
                    return f"‚ùå –û—à–∏–±–∫–∞ API: {response.status}"
    
    except asyncio.TimeoutError:
        logger.error("Timeout calling Hugging Face API")
        return "‚è≥ –¢–∞–π–º–∞—É—Ç API, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑"
    except Exception as e:
        logger.error(f"Error calling Hugging Face API: {e}")
        return f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ API: {str(e)}"

def format_episode_summary(summary: str, file_name: str) -> str:
    episode_name = file_name.replace('.srt', '').replace('.docx', '')
    formatted_summary = f"""üì∫ **–ö—Ä–∞—Ç–∫–∏–π –ø–µ—Ä–µ—Å–∫–∞–∑: {episode_name}**

||{summary.strip()}||

_–ü–µ—Ä–µ—Å–∫–∞–∑ —Å–æ–∑–¥–∞–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∏–∞–ª–æ–≥–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π_"""
    
    return formatted_summary

def extract_text_from_docx(file_path: str) -> str:
    try:
        doc = Document(file_path)
        text_parts = []
        for paragraph in doc.paragraphs:
            if paragraph.text.strip():
                text_parts.append(paragraph.text.strip())
        
        full_text = '\n'.join(text_parts)
        logger.info(f"Extracted {len(full_text)} characters from DOCX")
        return full_text
    except Exception as e:
        logger.error(f"Error extracting text from DOCX: {e}")
        raise e

def extract_text_from_srt(file_path: str) -> str:
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        blocks = content.strip().split('\n\n')
        dialogue_lines = []
        
        for block in blocks:
            lines = block.strip().split('\n')
            if len(lines) >= 3:
                text_lines = lines[2:]
                for text_line in text_lines:
                    text_line = text_line.strip()
                    if text_line and '[' in text_line and ']' in text_line:
                        dialogue_lines.append(text_line)
        
        full_text = '\n'.join(dialogue_lines)
        logger.info(f"Extracted {len(dialogue_lines)} dialogue lines from SRT")
        return full_text
    except Exception as e:
        logger.error(f"Error extracting text from SRT: {e}")
        raise e

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    welcome_message = """üé¨ **–ë–æ—Ç –¥–ª—è –ø–µ—Ä–µ—Å–∫–∞–∑–∞ —Å–µ—Ä–∏–π**

–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Ñ–∞–π–ª —Å—É–±—Ç–∏—Ç—Ä–æ–≤ –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç:
üé¨ `.srt` - —Ñ–∞–π–ª —Å—É–±—Ç–∏—Ç—Ä–æ–≤ —Å –¥–∏–∞–ª–æ–≥–∞–º–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
üìÑ `.docx` - –¥–æ–∫—É–º–µ–Ω—Ç —Å –¥–∏–∞–ª–æ–≥–∞–º–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ [–ò–º—è]: —Ç–µ–∫—Å—Ç

–Ø —Å–æ–∑–¥–∞–º –∫—Ä–∞—Ç–∫–∏–π –ø–µ—Ä–µ—Å–∫–∞–∑ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π —Å–µ—Ä–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∏–∞–ª–æ–≥–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π. –ü–µ—Ä–µ—Å–∫–∞–∑ –±—É–¥–µ—Ç —Å–∫—Ä—ã—Ç –ø–æ–¥ —Å–ø–æ–π–ª–µ—Ä, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ä—Ç–∏—Ç—å –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏–µ –¥—Ä—É–≥–∏–º.

**–í–∞–∂–Ω–æ:** –Ø –∏—Å–ø–æ–ª—å–∑—É—é —Ç–æ–ª—å–∫–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –≤–∞—à–µ–≥–æ —Ñ–∞–π–ª–∞ –∏ –Ω–µ –¥–æ–±–∞–≤–ª—è—é –Ω–∏—á–µ–≥–æ –æ—Ç —Å–µ–±—è.

–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª –∏ –∂–¥–∏—Ç–µ –ø–µ—Ä–µ—Å–∫–∞–∑!"""
    
    await update.message.reply_text(welcome_message, parse_mode=ParseMode.MARKDOWN)

async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        logger.info("Received document message")
        
        if not update.message or not update.message.document:
            logger.warning("No document in message")
            return
        
        file = update.message.document
        file_name = file.file_name or "unknown"
        file_size = file.file_size or 0
        
        logger.info(f"Processing file: {file_name}, size: {file_size} bytes")
        
        if file_size > 20 * 1024 * 1024:
            await update.message.reply_text("‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å–∏–º—É–º 20MB)")
            return
        
        if not (file_name.lower().endswith('.docx') or file_name.lower().endswith('.srt')):
            await update.message.reply_text(
                "‚ùå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã .srt (—Å—É–±—Ç–∏—Ç—Ä—ã) –∏ .docx (–¥–æ–∫—É–º–µ–Ω—Ç—ã)\n"
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª —Å—É–±—Ç–∏—Ç—Ä–æ–≤ —Å –¥–∏–∞–ª–æ–≥–∞–º–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π."
            )
            return
        
        status_message = await update.message.reply_text("üîÑ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –¥–∏–∞–ª–æ–≥–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π...")
        
        await context.bot.send_chat_action(
            chat_id=update.effective_chat.id, 
            action=ChatAction.TYPING
        )
        
        file_path = f"/tmp/{file_name}"
        
        try:
            logger.info("Downloading file...")
            file_obj = await file.get_file()
            await file_obj.download_to_drive(file_path)
            
            logger.info("Extracting dialogue text...")
            if file_name.lower().endswith('.docx'):
                raw_text = extract_text_from_docx(file_path)
            else:
                raw_text = extract_text_from_srt(file_path)
            
            if not raw_text or not raw_text.strip():
                await status_message.edit_text("‚ùå –§–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∏–∞–ª–æ–≥–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π")
                return
            
            episode_text = prepare_episode_text(raw_text)
            
            if not episode_text or len(episode_text) < 100:
                await status_message.edit_text("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∏–∞–ª–æ–≥–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–µ—Ä–µ—Å–∫–∞–∑–∞")
                return
            
            await status_message.edit_text("ü§ñ –°–æ–∑–¥–∞—é –ø–µ—Ä–µ—Å–∫–∞–∑ —Å–µ—Ä–∏–∏...")
            
            logger.info("Creating episode summary...")
            summary = await summarize_episode_with_huggingface(episode_text, file_name)
            
            await status_message.delete()
            
            await update.message.reply_text(
                summary, 
                parse_mode=ParseMode.MARKDOWN,
                reply_to_message_id=update.message.message_id
            )
            
            logger.info("Successfully created episode summary")
        except Exception as e:
            logger.error(f"Error processing file {file_name}: {e}")
            await status_message.edit_text(
                f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: {str(e)}\n"
                "–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∏–∞–ª–æ–≥–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ [–ü–µ—Ä—Å–æ–Ω–∞–∂]: —Ç–µ–∫—Å—Ç"
            )
        finally:
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)
                    logger.info("Temporary file removed")
                except Exception as e:
                    logger.error(f"Error removing temp file: {e}")
    
    except Exception as e:
        logger.error(f"Unexpected error in handle_document: {e}")
        try:
            await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞")
        except:
            pass

def run_async_task(coro):
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á –≤ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ"""
    try:
        # –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ü–∏–∫–ª —Å–æ–±—ã—Ç–∏–π
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # –ï—Å–ª–∏ —Ü–∏–∫–ª —É–∂–µ –∑–∞–ø—É—â–µ–Ω, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø–æ—Ç–æ–∫
            result = asyncio.run_coroutine_threadsafe(coro, loop).result(timeout=30)
            return result
        else:
            return loop.run_until_complete(coro)
    except RuntimeError:
        # –ï—Å–ª–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ü–∏–∫–ª–∞, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
        return asyncio.run(coro)

async def init_application():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    global application
    application = ApplicationBuilder().token(BOT_TOKEN).build()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(MessageHandler(filters.Document.ALL, handle_document))
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    await application.initialize()
    return application

async def setup_webhook():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ–±—Ö—É–∫–∞"""
    global application
    if application is None:
        application = await init_application()
    
    await application.bot.set_webhook(f"{WEBHOOK_URL}/{BOT_TOKEN}")
    logger.info(f"Webhook set to {WEBHOOK_URL}/{BOT_TOKEN}")

@app.route(f"/{BOT_TOKEN}", methods=["POST"])
def webhook_handler():
    """–°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–±—Ö—É–∫–∞"""
    try:
        update_json = request.get_json(force=True)
        logger.info(f"Received webhook update: {update_json}")
        
        global application
        if application is None:
            logger.error("Application not initialized")
            return "error", 500
        
        update = Update.de_json(update_json, application.bot)
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        def process_update():
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                loop.run_until_complete(application.process_update(update))
                loop.close()
            except Exception as e:
                logger.error(f"Error in update processing thread: {e}")
        
        thread = threading.Thread(target=process_update)
        thread.daemon = True
        thread.start()
        
        return "ok"
    except Exception as e:
        logger.error(f"Error processing webhook update: {e}")
        return "error", 500

@app.route("/", methods=["GET"])
def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏"""
    return "Bot is running!"

def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ Flask-—Å–µ—Ä–≤–µ—Ä–∞ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–µ–±—Ö—É–∫–∞"""
    port = int(os.environ.get('PORT', 10000))

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤–µ–±—Ö—É–∫
    logger.info("Initializing application and setting up webhook...")
    asyncio.run(setup_webhook())

    # –ó–∞–ø—É—Å–∫–∞–µ–º Flask-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    logger.info(f"Starting Flask server on port {port}")
    app.run(host='0.0.0.0', port=port, debug=False, threaded=True)

if __name__ == '__main__':
    main()
